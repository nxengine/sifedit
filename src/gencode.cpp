
#include "gencode.h"

#include "sifedit.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

static uint32_t hash;

void accum_hash(const char *str);
void accum_hash(char ch);

// sprites.h: a simple .h file which declares constants for all the sprites in the sif
bool generate_sprites_h(const char *fname)
{
  std::string output;
  init_hash();

  output += std::string("\n");

  int nsprites = spritelist.CountItems();
  for (int i = 0; i < nsprites; i++)
  {
    std::string str("#define ");
    str += std::string(GetSpriteHeaderName(spritelist.SpriteAt(i)->Name()));
    str += std::string(" ");
    str += std::string(stprintf("%d", i));

    output += str;
    output += std::string("\n");

    accum_hash(str.c_str());
  }

  return write_file_if_needed(output, fname);
}

// AssignSprites.cpp: provides a function AssignSprites(), which assigns sprites
// to object types that have the same names as the sprite save for their
// OBJ_ instead of _SPR prefix.
bool generate_assignsprites_cpp(const char *fname)
{
  char line[1024];

  std::vector<std::string> objtypes;
  if (read_list_of_objtypes("./object.h", &objtypes))
    return 1;

  std::string output;
  init_hash();

  output += std::string("#include \"../game.h\"\n"
                      "#include \"../object.h\"\n"
                      "#include \"sprites.h\"\n"
                      "#define ASSIGN_SPRITE(OBJECT, SPRITE) objprop[OBJECT].sprite = SPRITE;\n"
                      "\n"
                      "void AssignSprites(void)\n"
                      "{\n");

  int nsprites = spritelist.CountItems();
  auto f = [](std::vector<std::string>& a, std::string b)
  {
    for (auto &it : a)
    {
        if (it == b)
          return true;
    }
    return false;
  };
  for (int i = 0; i < nsprites; i++)
  {
    const char *sprname = GetSpriteHeaderName(spritelist.SpriteAt(i)->Name());
    sprname += 4; // skip SPR_

    if (f(objtypes, std::string(sprname)))
    {
      sprintf(line, "  ASSIGN_SPRITE(OBJ_%s, SPR_%s);\n", sprname, sprname);
      accum_hash(line);
      output += std::string(line);
    }
  }

  output += std::string("}");

  return write_file_if_needed(output, fname);
}

bool read_list_of_objtypes(const char *hfile, std::vector<std::string> *names)
{
  FILE *fp;
  char line[1024];

  fp = fopen(hfile, "rb");
  if (!fp)
  {
    staterr("read_list_of_objtypes: couldn't open engine source file '%s'", hfile);
    return 1;
  }

  while (!feof(fp))
  {
    fgetline(fp, line, sizeof(line));

    // search for object definitions
    if (line[0] == '#' && strbegin(line + 1, "define"))
    {
      char *name;
      if ((name = strstr(line, "OBJ_")))
      {
        name += 4; // trim off OBJ_ prefix

        // trim "name" at first tab or space (in case there is a comment, etc)
        char *ptr = strpbrk(name, " \t/");
        if (ptr)
          *ptr = 0;

        names->push_back(std::string(name));
      }
    }
  }

  fclose(fp);
  return 0;
}

/*
void c------------------------------() {}
*/

bool write_file_if_needed(std::string& str, const char *fname)
{
  if (read_hash(fname) != hash) // avoid triggering unnecessary "make"-based recompilation
  {
    mkdir("autogen",0777);
    FILE *fp = fopen(fname, "wb");
    if (!fp)
    {
      staterr("('%s'): cannot open file", fname);
      return 1;
    }

    stat("regenerating file %s", fname);

    fprintf(fp, "// hash: %08x\n", hash);
    fprintf(fp, "// auto-generated by sifedit-evo %s\n", get_timestamp());

    fprintf(fp, "%s\n", str.c_str());
    fclose(fp);
  }

  return 0;
}

/*
void c------------------------------() {}
*/

void init_hash()
{
  hash = 0xac4279ae;
}

void accum_hash(const char *str)
{
  for (int i = 0; str[i]; i++)
    accum_hash(str[i]);
}

void accum_hash(char ch)
{
  uint32_t msb;

  // no particular math here at all. it's pretty much just random mangling.
  msb = (hash >> 24);
  hash <<= 3;
  hash += 3;
  hash ^= ch;
  hash ^= msb;

  // don't allow 0 because that's whats returned by read_hash on an error
  if (hash == 0)
    hash++;
}

uint32_t read_hash(const char *fname)
{
  FILE *fp;
  char line[1024];

  fp = fopen(fname, "rb");
  if (!fp)
    return 0;

  fgetline(fp, line, sizeof(line));
  fclose(fp);

  if (!strbegin(line, "// hash: "))
    return 0;
  return strtol(line + 8, NULL, 16);
}

const char *get_timestamp()
{
  char *str      = GetStaticStr();
  time_t curtime = time(NULL);

  strftime(str, 32, "%a %d %Y  %I:%M:%S%p", localtime(&curtime));
  return str;
}
